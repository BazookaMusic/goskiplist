package main

import (
	"fmt"
	"math/rand"
	"time"
)

type skiplist_node struct {
	value int
	next  *skiplist_node
	prev  *skiplist_node
	down  *skiplist_node
}
type skiplist struct {
	n_levels   uint32
	head       *skiplist_node
	n_elements int
	prob       float64
	max_levels uint32
}

func (head *skiplist) Height() uint32 {
	return head.n_levels
}

func (head *skiplist) Len() int {
	return head.n_elements
}

type NotFoundErr string

func (err NotFoundErr) Error() string {
	return "Element not found"
}
func Init_skiplist(prob float64, max_levels uint32) skiplist {
	var initial skiplist
	initial.n_levels = 1
	initial.prob = prob
	initial.max_levels = max_levels

	var head skiplist_node
	head.down = nil
	head.next = nil
	head.value = -1

	initial.n_elements = 0

	initial.head = &head

	return initial
}

func debug(a skiplist) {
	ins := a.head

	for ; ins != nil; ins = ins.down {
		counter := 0
		if ins.next == nil {
			fmt.Print(nil)
		}
		for node := ins.next; node != nil; node = node.next {
			counter++
			fmt.Print(" ", node.value)
		}
		fmt.Println(" nil", counter)
	}
}

func (head *skiplist) ToSortedArray() []int {
	arr := make([]int, head.n_elements, head.n_elements)
	curr_level := head.head
	for levels_down := head.n_levels; levels_down != 1; curr_level, levels_down = curr_level.down, levels_down-1 {
	}

	current_node := curr_level.next
	counter := 0
	for ; current_node != nil; current_node = current_node.next {
		arr[counter] = current_node.value
		//fmt.Print(arr[counter], current_node.value, " ")
		counter++
	}

	//fmt.Println(arr)

	return arr

}

func (head *skiplist) Find(val int) *skiplist_node {
	curr := head.head
	// vertically
	for ; curr != nil; curr = curr.down {
		// horizontally
		for ; curr.next != nil && curr.next.value < val; curr = curr.next {
		}
		//found something or have to go down

		// is the next element what I seek
		if curr.next != nil && curr.next.value == val {
			return curr.next
		}
	}
	// not found
	return nil
}

func (head *skiplist) Remove(val int) error {

	node := head.Find(val)

	if node == nil {
		// never found
		return new(NotFoundErr) // error
	} else {
		// traverse down and delete nodes
		for node != nil {

			node.prev.next = node.next
			if node.next != nil {
				node.next.prev = node.prev
			}
			node = node.down
		}

		// removed properly
		head.n_elements--
		return nil

	}

}

func (head *skiplist) Insert(val int) int {

	head.n_elements++

	levels := coin_tosses(head.prob, head.max_levels)
	//fmt.Println("element ", val, levels)
	ins_point := head.head

	if levels > head.n_levels {
		var i uint32 = 0
		for ; i < levels-head.n_levels; i++ {
			var new_node skiplist_node
			new_node.down = head.head
			new_node.value = -1
			head.head = &new_node
		}

		//fmt.Println("entered")
		head.n_levels = levels // new # of levels
	}

	ins_point = head.head

	var current_node *skiplist_node
	var prev *skiplist_node
	var above *skiplist_node

	above = nil
	var new_val *skiplist_node
	//fmt.Println("insertion point", ins_point)
	level := head.n_levels
	for ; ins_point != nil; ins_point, level = ins_point.down, level-1 {
		if level <= levels {
			new_val = new(skiplist_node)
			new_val.value = val // to be added
		}

		// connect above level
		if above != nil {
			above.down = new_val
		}

		prev = ins_point
		// traverse horizontally to find insertion point
		for current_node = ins_point.next; current_node != nil && current_node.value < val; prev, current_node = current_node, current_node.next {
		}

		// don't insert at current level if
		// too high
		if level > levels {
			ins_point = prev
			continue
		}

		// insert at the end
		prev.next = new_val
		new_val.next = current_node
		new_val.prev = prev
		above = new_val

		// don't start from the beginning
		ins_point = prev

	}
	return 0

}

func coin_tosses(prob float64, max_levels uint32) uint32 {
	var counter uint32 = 1
	res := rand.Float64()
	for res > prob && counter < max_levels {
		counter++
		res = rand.Float64()
	}

	return counter

}

func eval_sort(arr []int) {
	prev := arr[0]
	for index := 1; index < len(arr); index++ {
		if arr[index] < prev {
			fmt.Println(prev, arr[index], index)
		}
		prev = arr[index]
	}

	fmt.Println(len(arr))
}

func main() {
	rand.Seed(time.Now().UTC().UnixNano())

	var head skiplist
	head = Init_skiplist(0.5, 20)

	var arr []int = make([]int, 10000000)
	for index := 0; index < 1000000; index++ {
		head.Insert(rand.Intn(1234500))
		arr[index] = index
	}

	//sort.Ints(arr)

	sorted := head.ToSortedArray()
	eval_sort(sorted)
	fmt.Println(head.Len())

	//debug(head)
}
